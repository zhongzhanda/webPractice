### 简单描述
1. 表情会从显示框上方出现，然后垂直移动到显示框下方。  
2. 表情移动的过程中，可以点击。
  - 如果点击到该表情，则得一分；并且该表情会变为黑色头像的表情，继续向下移动一段距离，同时会左右晃动，然后消失。  
  - 如果没有点击到该表情，表情移动到显示框底部时停止移动，然后显示框会上下晃动，随后表情消失；并且失一分。  
3. 出现的表情是随机的。
4. 表情出现的水平位置也是随机的。  
5. 表情向下移动的速度随游戏的进行而逐渐加快。  
6. 当失分达到10分时，游戏结束。
  

### 原项目中写的小游戏有三个bug：
1. 表情移动到底部触发显示框上下晃动后，依旧可以点击，而这次点击事件会延时到下个表情上触发。
2. 游戏结束后，顶部还会出现一个新的表情，可以点击该表情开始游戏，也可以点击按钮开始游戏。
3. 继续新的游戏时表情下落速度是从之前结束的基础上开始的。
4. 第二个bug和第一个bug相结合，会导致关闭弹窗后立即开始下一次游戏。
5. 这是一个猜想：第一个bug和第三个bug相结合会导致点击事件延迟到第三个甚至更后面的表情上触发？
  
  
```flow
st=>start: Start
op-prepare=>operation: 1.计算随机的表情
2.计算随机的水平位置
3.计算移动速度
4.增加移动速度
op-startmove=>operation: 添加表情图片
图片从上到下开始运动
op-stopmove=>operation: 图片停止移动
op-utdshake=>operation: 显示框上下晃动
并且此时表情点击没有反应
失一分
op-motiondisappear=>operation: 图片消失
op-click=>operation: 鼠标点击图片事件
op-donothing=>operation: 什么也不做
op-ltrshake=>operation: 1.图片变成黑色哭泣脸
2.图片左右晃动
3.得一分
cond1=>condition: 是否移动到底部？
cond2=>condition: 游戏是否结束？
cond3=>condition: 图片是否移动到底部？
ed=>end: 结束游戏

st->op-prepare->op-startmove->cond1(yes)->op-stopmove->op-utdshake->op-motiondisappear->cond2(yes)->ed
cond2(no)->op-prepare
cond1(no)->op-click->cond3(no)->op-ltrshake->op-motiondisappear
cond3(yes)->op-donothing
```
### 综上，这个小游戏应该包含的主要方法和主要步骤：
1. 动画开始前的一些准备：表情，位置，速度（按速度计算每次移动间隔的时间）。
2. 创建表情图片
3. 开始移动：每隔一段时间移动一段距离，每次移动后检查是否到达底部，如果没有到达底部，就继续移动；如果到达底部，则停止移动。
4. 点击图片：检查图片是否移动到底部，如果是，则点击无效；如果不是，则发生点击事件。
5. 图片消失，判断是否结束游戏。


### 伪程序
```JS
btn.onclick = function () {
  initGlobalProperties();   //初始化全局属性
  startGame(); //开始游戏
};

function startGame () {
  createImg();    //创建图片
  initProperties();     // 初始化局部变量
  startMove();    // 图片开始移动
};

function startMove () {
  setInterval(()=>{
    if (图片未到达底部) {
      图片向下移动;
    } else {
      图片停止移动;

      if （图片已经被点击过）{
        什么也不做;
      } else {
        gameContentShake();   //游戏框上下抖动

        // isGameOver中存在去除图片的步骤，所以isGameOver函数需要等到抖动动画结束后才能启用。
        isGameOver();   // 后处理程序
      }
    }
  }, interval);

  img.onclick = function () {
    if (图片已经到达底部) {
      什么也不做;
    } else {
      motionShake();    // 图片抖动

      // isGameOver中存在去除图片的步骤，所以isGameOver函数需要等到抖动动画结束后才能启用。
      isGameOver();     // 后处理程序
    }
  };
};

// 这个函数中集合了一些其它的动作，集合在里面只是因为这个游戏比较简单，那些动作也比较简单，所以就放在一起了
function isGameOver () {
  removeImg();    // 移除图片
  
  // 检测游戏是否结束
  if (丢掉的分数 === 10) {    //丢掉10分就结束游戏
    gameEnd();  // 游戏结束
  } else {
    startGame();  // 继续游戏
  }
};
```


### 一些做完之后的想法
1. 这个游戏当中有两个晃动，一个是表情图标的晃动，一个是整个游戏框的晃动。这两个晃动分别使用了不同的方式实现。表情的晃动是通过JS控制表情的left属性来实现的；游戏框的晃动则是通过CSS的animation属性来实现。表情的晃动不能通过animation实现是因为表情的left值不是固定的，CSS无法读取元素的属性，只能设置元素的属性。
2. 一开始制作的游戏中，表情图标是会被拖动的，看了原作发现了一个新的事件：ondragstart。
2. 我这里的下落动画是通过setInterval来实现的，为了让下落动画更流畅，每次下落的距离较短，时间间隔也较短；而且是通过减小时间间隔的方式来加快速度的。
3. 关于下落动画流畅度的问题，也许可以通过transform属性来实现。JS只是控制下落距离，两次距离之间下落效果通过transform来实现。使用这种方法的话，下落之间的时间是由transform控制，所以一般是相等的，那只能通过修改下落距离来控制下落速度。
4. 开始按钮还应该有一些其它功能，比如：暂停游戏，继续游戏。如果添加 暂停/继续 功能，则需要添加一个全局属性来标志游戏是否暂停，在图标发生点击事件时，首先需要检查游戏是否暂停。 暂停游戏其实就是取消表情下落，通过clearInterval即可实现；继续游戏则是重新设置一个相同的setInterval即可。
5. 由第4点想到，可能有两个地方会用到相同的setInterval，或许可以将setInterval单独提出来，放入一个方法当中。
6. 还是由第4点想到的，在暂停的时候，也许可以可以通过添加一个蒙版层，蒙版层背景设置成白灰色半透明，这样整个游戏看起来就像被冻结了一样，而且这样也点击不到表情图标，也就少了一层逻辑判断。
7. 由第6点想到，游戏结束的时候可以不使用alert，也可以使用一个黑色半透明的蒙版层来实现，这样的好处是可以在蒙版层上添加其它的信息。
8. 可以结合localstorage来储存最高分。或者干脆用indexedDB来保存历史成绩，从而做一个成绩的排名。
9. 我写的游戏中的图片能够被选中，类似文字被选中，原作中是不会被选中的， <s>我猜测可能是因为原作中把图片转为了块元素</s>。
10. 原作中图片元素原先就已经存在，后面只是填入图片路径，以及重新设置left值。这样做的好处就是减少了性能开销，但是缺点就是出现的图片的数量是固定的。


### 总结：
##### 关于程序流程的总结
1. 


##### 关于游戏的总结
1. 



### 其它的乱七八糟的想法
通过这个游戏想到了小时候的FC打飞机的游戏（其实是想到了前两年很火的打飞机小游戏，但我没玩过，不给想来应该差不多吧），在那个游戏里，有各种不同样式的飞机，各种不同样式的飞机有不同的飞行轨道，不同的射击方式。自己控制的小飞机也可以进行射击。飞机可以被摧毁。  
不同的飞机具有不同的体型大小，不同的移动轨迹，不同的攻击方式，即不同的子弹类型（通常是样式不同，子弹数量不同，子弹轨迹不同）。  
还有就是碰撞检测，敌机和敌机发射的子弹认为是一方，自己的飞机和自己飞机射出的子弹认为是一方。 首先是子弹和子弹是否可以互相抵消？（这个一般是不能抵消，也就是不会发生碰撞），其次是不是同一方的子弹和飞机，以及不是同一方的飞机和飞机必然会发生碰撞，这里又有一个问题，飞机是碰一下就死还是需要碰几下才死（即是否拥有血条，如果拥有学条，还需要对子弹进行伤害设置）。  
以上就是一些粗浅的，没有太多条理的想法。也许以后会做一个类似的射击小游戏，但现阶段，既不会设计游戏关卡、难度，编程能力也还是很弱（碰撞检测还不知道怎么写？不同子弹的轨迹也不知道该用什么来实现？画面中飞机数量一多，必然会导致内存，cpu需求的上升，要怎么在保证游戏流畅的前提下降低游戏所需要的i性能？）

